\begin{comment}
It is possible to translate live sequence charts to LTL \cite{KUMAR, KUMAR2009137}. These translations result in large intractable formulas whereas the work here creates several connected small formulas that are easy for SPIN. UML modeling uses \emph{synchronous observer automata} to encode and verify safety properties \cite{8906967}. The CWP can be thought of as a synchronous observer, and it is possible to express it in SPIN for safety verification, but that complicates existential properties and may result in a larger state space. Other work verifies that UML state diagrams implement their associated activity diagrams (workflows) with the NuSMV model checker \cite{7436156}. The workflows are turned into LTL, just opposite of the work here. That said, it is possible to extract a CWP from workflow models, in which case the intent is to discover what the system will accomplish.

There is some work related in translating models in the \emph{Business Process Execution Language} (BPEL) to Promela \cite{bpelToPromela}. The semantics are different and is limited in scope to web-services. BPMN choreographies have been modeled in Promela and verified with SPIN for deadlock, but choreographies ignore workflows and only model message sequencing \cite{choreography}. The translation of BPMN to Promela is inspired by existing methods for turning Petri Nets into equivalent Promela models \cite{petrinetToPromela, petrinetInspiration}. These however do not include data. The translation in this paper is also based off of early prototype translations of BPMN to Promela using message channels for synchronization \cite{bpmn2promela} whereas the translation here uses global variables to mitigate state explosion.
\end{comment}

The problem of verifying various properties of visual workflows has been addressed to various extents. In \cite{workflowVerification1}, they use Hoare logic to formally introduce and verify workflow semantics. In \cite{workflowVerification2}, they present the theoretical framework for applying propositional logic to workflow verification. In \cite{workflowVerification3}, they present a taxonomy on the state of grid workflow verification and validation. In \cite{workflowVerification4}, they present an automated tool for translation from YAWL into DVE in order to perform property verification using DiVinE, a model checker. In \cite{workflowVerification5}, they use a petri-net approach to analyze workflows for compositional and control-flow errors in workflows. In \cite{workflowVerification6}, they explore the viability of model checking in a single workflow domain, and show that it can be effective. In \cite{workflowVerification7}, they use ontologies to verify the replicability of scientific workflows.

There are several examples of efforts to apply concrete execution semantics to BPMN workflows. In \cite{BPMNExecutionSemantics1}, they present the symbolic encodings of the execution semantics of BPMN in the form of LTL. In \cite{BPMNExecutionSemantics2}, they use graph rewrite rules to formalize BPMN execution semantics and further use these rules to verify process engines. In \cite{BPMNExecutionSemantics3}, they define an abstract model for the dynamic semantics of BPMN 2.0 and use that model to implement a native BPMN 2.0 process engine. In \cite{BPMNExecutionSemantics4}, they define an ASM designed to rigorously specify the semantics of BPMN process diagrams. They also identify inconsistencies and ambiguities in the BPMN specification and attempt to fix them. In \cite{BPMNExecutionSemantics5}, they show how a subset of the BPMN specification can be given a process semantics in Communicating Sequential Processes. In \cite{BPMNExecutionSemantics6}, they provide a direct formalization of the operational semantics of BPMN in terms of Labelled Transition Systems. In \cite{BPMNExecutionSemantics7}, they propose a formal semantics in terms of a mapping to Petri Nets and implement said mapping. Each of these efforts inspired us in our own BPMN semantic assumptions.

A core component of our paper is automated Promela code generation. Similar techniques for code generation have been used in several papers. In \cite{promelaGeneration1}, \cite{promelaGeneration2} and \cite{promelaGeneration3}, they generate Promela code from Specification and Description Language (SDL) system specifications. In \cite{promelaGeneration4}, they translate UML sequence diagrams into Promela for the purpose of verifying LTL properties. In \cite{promelaGeneration5}, they perform a program-to-model transformation on C# code using the Microsoft Roslyn technique. In \cite{promelaGeneration6}, they present a case study using CINCO, a code generation framework, to rapidly construct custom graphical interfaces for multi-faceted, concurrent systems. In \cite{promelaGeneration7}, they add Promela as a supported output language to the Reo compiler.

Several papers have represented workflows as code in some way.  Some translate the workflow into a language that is used specifically for verification \cite{codeBasedModel1} \cite{codeBasedModel2}, while others use the non-visual executable counterpart to BPMN, Business Process Execution Language (BPEL). \cite{BPEL} \cite{codeBasedModel3} \cite{codeBasedModel4}

Several papers have used a petri net structure to represent workflow models. In \cite{petriNet1}, they introduce workflow management as an application domain for Petri nets. In \cite{petriNet2}, they review and classify available papers on Petri net-based modeling of workflows. In \cite{petriNet3}, timed Petri nets are used to show that certain behavioral properties of workflow processes can be verified. In \cite{petriNet4}, they verify process control specifications using state-of-the-art Petri net based analysis techniques. In \cite{petriNet5}, they use colored petri nets to assist in modeling families of workflow processes with similar process routes and logic rules.
\COMMENT{petriNet6 is an older paper on petri net application to workflow management}

The construct we use to represent the work needing to be done, the CWP, is used in several papers. This presentation uses CWPs to define the work of a patient-centered case management system \cite{CWPRW1}. In \cite{CWPRW2} and \cite{CWPRW3}, CWPs are used in conjunction with model checking to verify properties of health systems. In \cite{CWPRW4} and \cite{CWPRW5}, CWPs are used in the design process of health IT systems.

We derive a set of LTL properties using a visual state diagram. Representing LTL visually can increase its effective use in business settings dramatically. Others have also implemented methods of visually representing LTL properties. In \cite{LTLVisualization1}, LTL is extracted from UML diagrams. In \cite{LTLVisualization2}, the authors propose two alternative visual notations for specifying temporal properties. In \cite{LTLVisualization3}, a graphical specification environment for LTL specifications using touchscreen technologies is proposed. In \cite{LTLVisualization4}, the BPMN notation is extended to include descriptions of LTL rule to be verified.

As mentioned previously, we anticipate this work being useful in conjunction with hierarchical verification in situations where sub-processes or call activities are used. Hierarchical verification has been studied and used in many papers. In \cite{hierarchicalVerification1}, a compositional verification approach called Assume-guarantee reasoning is introduced and demonstrated on a simplified train control system. In \cite{hierarchicalVerification2}, the authors use edge-valued binary decision diagrams to enable multilevel and hierarchical verification of simple designs. In \cite{hierarchicalVerification3}, the authors use BPMN partitioning and colored Petri nets to enable a hierarchical verification technique for the state space analysis of BPMN workflows. In \cite{hierarchicalVerification4}, \cite{hierarchicalVerification6} and \cite{hierarchicalVerification7}, the authors develop and implement theories of hierarchical verification of speed-independent, asynchronous, and Galois field circuits, where specifications at one level of abstractions can be used as descriptions at higher levels of abstraction. In \cite{hierarchicalVerification5}, the authors introduce hierarchical concepts into artifact verification.
